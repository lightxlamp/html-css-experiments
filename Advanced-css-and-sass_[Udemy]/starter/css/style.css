/*
COLORS:
Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485
*/

*,
*::after, /* Такой прикол вообще первый раз вижу... */
*::before {
    box-sizing: inherit; /* each element will inherit box-sizing from its parent element - body.
    Slightly better practice */
	/* The box-sizing property allows us to include the padding 
    and border in an element's total width and height. */
	margin: 0px;
    padding: 0px;
}

html {
    /* font-size: 10px; */  /* This is a bad practice. May be user has a bad sight
     and change this setting for his browser. And we overwriting it here */
    font-size: 62.5%; /* So we take 62.5% from 16px (default browser setting) to get our 
    easy-to-calculate-rems-on - 10px! Getting 10px in "correct/proper" way */
    /* rems IE9 => */
}

body {
	color: #777;
	font-family: "Lato", sans-serif;
	/* Прикольно, что импортируемый в кавычках вроде */
	/* font-size: 16px; */
	font-size: 1.6rem;
	font-weight: 400;
	line-height: 1.7;
    /* еще раз... что есть базовое значение, которое мы умножаем на 1.7 */
    /* A number that will be multiplied with the current font-size to set the line height */
	/*padding: 30px; */
    padding: 3rem;
    box-sizing: content-box;
}

.header {
	/* border: 5px solid red; */
	background-image: linear-gradient( to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 131, 0.8)), url('../img/hero.jpg');
	background-size: cover;
	/* Если уменьшаю масштаб. браузера... картинка теперь не дублируется "6 раз" */
	background-position: top;
	/* При смене viewport'а привязка изображения к какой-либо стороне */
	clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
	/*  Про vh тут сразу знал.. Он сначала px написал*/
	/* clip-path: polygon(0% 0%, 100% 0%, 100% 75%, 75% 75%, 75% 100%, 50% 75%, 0% 75%); */
    /* from the site: https://bennettfeely.com/clippy/ */
    /* CSS свойство clip-path создает ограниченную область, которая определяет какая часть элемента должна быть видимой. */
    /* more info about clip-path: https://developer.mozilla.org/ru/docs/Web/CSS/clip-path */
	height: 95vh;
	/* view port height... Крутая штука.. Сейчас поиграемся */
	/* за 24 минуты видео - хорошо узнал) */
	position: relative;
	/* TODO. Зачем он тут... выяснить*/
	/* UPD понял... без указания, logo-box считает от начала документа   */
}

.header__logo-box {
	/* left: 40px; */
	left: 4rem;
	position: absolute;
	/* top: 40px; */
	top: 4rem;
}

.header__logo {
	/* height: 35px; */
	height: 3.5rem;
}

.heading-primary {
	color: white;
	text-transform: uppercase;
	/* -webkit-backface-visibility: hidden; Safari */
	/* backface-visibility: hidden;  To fix shaky issue. But I can't see it... */
}

.heading-primary--main {
    animation-name: headerTextAnimation;
	animation-duration: 1s;
	/* animation-delay: 4s;
    animation-iteration-count: 3; */
	display: block;
	/* Я бы просто <br/> Использовал. А тут вот какая хитрость.  
    Блочный элемент растягивается на всю длинну parent'a и до и после себя ставит linebreaks*/
	/* font-size: 60px; */
	font-size: 6rem;
	font-weight: 400;
    /* letter-spacing: 35px; */
    letter-spacing: 3.5rem;
}

.heading-primary--sub {
	/* animation-name: headerSubTextAnimation;
    animation-duration: 1s; 
    animation: name duration timing-function delay iteration-count direction fill-mode; */
	animation: headerSubTextAnimation 1s ease-out;
	display: block;
	/* added during animation lesson only. Animation does not work without it */
	/* font-size: 20px; */
	font-size: 2rem;
	font-weight: 700;
	/* letter-spacing: 17.4px; */
	letter-spacing: 1.75rem;
	/* margin-bottom: 60px; */
	margin-bottom: 6rem;
}

.header__text-and-button {
	position: absolute;
	left: 50%;
	top: 40%;
	transform: translate(-50%, -50%);
    /* element itself */
    /* https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate */
	text-align: center;
	/* aligns button at center. Insead of applyting transform to button */
}


/* Definition and Usage. The @keyframes rule specifies the animation code. 
The animation is created by gradually changing from one set of CSS styles to another. 
During the animation, you can change the set of CSS styles many times. */

@keyframes headerTextAnimation {
	/* ! Browsers are only optimezed to animate opacity and transform properties */
	0% {
		opacity: 0;
		/* color: red; */
		transform: translateX(-100px);
	}
	30% {
		opacity: .3;
		/* color: darkorange; */
	}
	50% {
		opacity: .5;
		/* color: blue; */
	}
	80% {
		transform: translateX(10px);
	}
	100% {
		opacity: 1;
		/* color: yellow; */
	}
}

@keyframes headerSubTextAnimation {
	0% {
		opacity: 0;
		/* transform: translateX(100px); */
		transform: translateX(100rem);
	}
	80% {
		/* transform: translateX(-10px); */
		transform: translateX(-1rem);
	}
	100% {
		opacity: 1;
	}
}

@keyframes headerButtonAnimation {
	0% {
		opacity: 0;
		/* transform: translateY(30px); */
		transform: translateY(3rem);
	}
	100% {
		opacity: 1;
	}
}

/* We use pseudo classes to style elements under a special condition
:link is a special state of ... :visited */

.btn:link,
.btn:visited {
	text-decoration: none;
	text-transform: uppercase;
	/* padding: 15px 40px; */
	padding: 1.5rem 4rem;
	display: inline-block;
	/* Я бы просто block поставил... И это оказывается бы проблема была... */
	/* I knew only display:block.. What the difference between them
    https://www.computerhope.com/issues/ch001717.htm. Got it know :p Display block takes all row/line. 
    inline-block behaves like inline element. Кстати у автора оговорка кстати на 7:10 */
    /* border-radius: 100px; */
    border-radius: 10rem;
    transition: all .2s;
    position: relative; 
    /* this position was added, so btn::after absolute can refer to it */
}

.btn:hover {
    transform: translateY(-3px);
    /* box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2); */
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
    /* x-offset, y-offset, blur */
}

.btn:active {
    transform: translateY(-1px);
    /* box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2); */
    box-shadow: 0 .5rem 1rem rgba(0, 0, 0, 0.2);
	/* when user presses on button :active pseudo class applies */
}

.btn::after {
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    /* border-radius: 100px; */
    border-radius: 10rem;

    /* to hide new button behind */
    /* ::after - creates a copy of a button */
    position: absolute; 
    /* position will try to find first ref. The first ref now is "header text and button" div. We need to change it */
    /* so we added position relative to .btn:link */
    top: 0;
    left: 0;
    z-index: -1;
    transition: .4s;
    /* https://www.w3schools.com/css/css3_transitions.asp */
}

.btn--white::after {
    background-color: #fff;
}

.btn:hover::after {
    transform: scaleX(1.4) scaleY(1.6);
    opacity: 0;
}

.btn--white {
	background-color: #fff;
	color: #777;
}

.btn--animated {
    /* animation-name: headerButtonAnimation;
	animation-duration: .5s;  */
    animation: headerButtonAnimation .5s ease-out .75s;
    animation-fill-mode: backwards; /* added because after adding delay. 4th animation param*/
    /* The animation-fill-mode property defines what values 
    are applied by an animation outside the time it is executing. 
    animation-fill-mode: backwards; also worked for me in this case - the same way
    animation-fill-mode = Определяет, какие стили должны применяться к элементу, когда анимация не проигрывается. 
    Например, после её завершения или при остановке. 
    По умолчанию, в момент окончания анимации стиль элемента возвращается к исходному, 
    свойство animation-fill-mode позволяет изменить это поведение и сделать так, чтобы стиль элемента 
    оставался как у последнего ключевого кадра.
    */
}

.line-height-test {
    font-size: 3.5rem;
    line-height: 10;
}