@charset "UTF-8";
/* Definition and Usage. The @keyframes rule specifies the animation code. 
The animation is created by gradually changing from one set of CSS styles to another. 
During the animation, you can change the set of CSS styles many times. */
@keyframes headerTextAnimation {
  /* ! Browsers are only optimezed to animate opacity and transform properties */
  0% {
    opacity: 0;
    transform: translateX(-100px); }
  30% {
    opacity: .3; }
  50% {
    opacity: .5; }
  80% {
    transform: translateX(10px); }
  100% {
    opacity: 1; } }

@keyframes headerSubTextAnimation {
  0% {
    opacity: 0;
    transform: translateX(100rem); }
  80% {
    transform: translateX(-1rem); }
  100% {
    opacity: 1; } }

@keyframes headerButtonAnimation {
  0% {
    opacity: 0;
    transform: translateY(3rem); }
  100% {
    opacity: 1; } }

*,
*::after,
*::before {
  box-sizing: inherit;
  /* each element will inherit box-sizing from its parent element - body.
    Slightly better practice */
  /* The box-sizing property allows us to include the padding 
    and border in an element's total width and height. */
  margin: 0px;
  padding: 0px; }

html {
  /* font-size: 10px; */
  /* This is a bad practice. May be user has a bad sight
     and hes/she changed this setting for his/her browser. And we overwriting this setting here */
  font-size: 62.5%;
  /* So we take 62.5% from 16px (default browser setting) to get our 
    easy-to-calculate-rems-on - 10px! Getting 10px in "correct/proper" way */
  /* rems IE9 => */
  /* font-size was not moved into "typography" section. Because it like an overall setting for all sizes*/ }

body {
  box-sizing: content-box; }

body {
  color: #777;
  font-family: "Lato", sans-serif;
  /* Прикольно, что импортируемый в кавычках вроде */
  /* font-size: 16px; */
  font-size: 1.6rem;
  font-weight: 400;
  line-height: 1.7;
  /* еще раз... что есть базовое значение, которое мы умножаем на 1.7 */
  /* A number that will be multiplied with the current font-size to set the line height */
  /*padding: 30px; */
  padding: 3rem;
  box-sizing: content-box; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
  margin-bottom: 6rem; }
  .heading-primary--main {
    animation-name: headerTextAnimation;
    animation-duration: 1s;
    /* animation-delay: 4s;
        animation-iteration-count: 3; */
    display: block;
    /* Я бы просто <br/> Использовал. А тут вот какая хитрость.  
        Блочный элемент растягивается на всю длинну parent'a и до и после себя ставит linebreaks*/
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem; }
  .heading-primary--sub {
    /* animation-name: headerSubTextAnimation;
        animation-duration: 1s; 
        animation: name duration timing-function delay iteration-count direction fill-mode; */
    animation: headerSubTextAnimation 1s ease-out;
    display: block;
    /* added during animation lesson only. Animation does not work without it */
    font-size: 2rem;
    font-weight: 700;
    /* letter-spacing: 17.4px; */
    letter-spacing: 1.75rem;
    margin-bottom: 6rem; }

.heading-secondary {
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  display: inline-block;
  background: linear-gradient(to right, #7ed56f, #28b485);
  -webkit-background-clip: text;
  color: transparent;
  letter-spacing: .2rem;
  transition: all .2s; }
  .heading-secondary:hover {
    transform: skewY(2deg) skewX(15deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2); }

.heading-tertiary {
  font: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font: 1.6rem; }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

.u-center-text {
  text-align: center; }

.u-margin-bottom-small {
  margin-bottom: 1.5rem; }

.u-margin-bottom-medium {
  margin-bottom: 4rem; }

.u-margin-bottom-big {
  margin-bottom: 8rem; }

.btn {
  /* We use pseudo classes to style elements under a special condition
    :link is a special state of ... :visited */ }
  .btn:link, .btnvisited {
    text-decoration: none;
    text-transform: uppercase;
    padding: 1.5rem 4rem;
    display: inline-block;
    /* Я бы просто block поставил... И это оказывается бы проблема была... */
    /* I knew only display:block.. What the difference between them
        https://www.computerhope.com/issues/ch001717.htm. Got it know :p Display block takes all row/line. 
        inline-block behaves like inline element. Кстати у автора оговорка кстати на 7:10 */
    border-radius: 10rem;
    transition: all .2s;
    position: relative;
    /* this position was added, so btn::after absolute can refer to it */ }
  .btn:hover {
    transform: translateY(-3px);
    /* box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2); */
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
    /* x-offset, y-offset, blur */ }
    .btn:hover::after {
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0; }
  .btn:active {
    transform: translateY(-1px);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2);
    /* when user presses the button :active pseudo class applies */ }
  .btn::after {
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 10rem;
    /* to hide new button behind */
    /* ::after - creates a copy of a button */
    position: absolute;
    /* position will try to find first ref. The first ref now is "header text and button" div. We need to change it */
    /* so we added position relative to .btn:link */
    top: 0;
    left: 0;
    z-index: -1;
    transition: .4s;
    /* https://www.w3schools.com/css/css3_transitions.asp */ }
  .btn--white {
    background-color: #fff;
    color: #777; }
    .btn--white::after {
      background-color: #fff; }
  .btn--animated {
    /* animation-name: headerButtonAnimation;
        animation-duration: .5s;  */
    animation: headerButtonAnimation .5s ease-out .75s;
    animation-fill-mode: backwards;
    /* added because after adding delay. 4th animation param*/
    /* The animation-fill-mode property defines what values 
        are applied by an animation outside the time it is executing. 
        animation-fill-mode: backwards; also worked for me in this case - the same way
        animation-fill-mode = Определяет, какие стили должны применяться к элементу, когда анимация не проигрывается. 
        Например, после её завершения или при остановке. 
        По умолчанию, в момент окончания анимации стиль элемента возвращается к исходному, 
        свойство animation-fill-mode позволяет изменить это поведение и сделать так, чтобы стиль элемента 
        оставался как у последнего ключевого кадра.
        */ }

.btn-text:link, .btn-text:visited {
  font-size: 1.6rem;
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 3px;
  transition: all .2s; }

.btn-text:hover {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  transform: translateY(-2px); }

.btn-text:active {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  transform: translateY(0); }

.row {
  max-width: 114rem;
  margin: 0 auto; }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    content: "";
    display: table;
    clear: both; }
  .row [class^="col-"] {
    float: left; }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc((100% - 6rem * 2) / 3); }
  .row .col-2-of-3 {
    width: calc( ( (100% - 6rem * 2) / 3 * 2) + 6rem); }
  .row .col-1-of-4 {
    width: calc((100% - 6rem * 3) / 4); }
  .row .col-2-of-4 {
    width: calc( ( (100% - 6rem * 3) / 4 * 2) + 6rem); }
  .row .col-3-of-4 {
    width: calc( ( (100% - 6rem * 3) / 4 * 3) + 2 * 6rem); }

.header {
  /* border: 5px solid red; */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/hero.jpg");
  background-size: cover;
  /* Если уменьшаю масштаб. браузера... картинка теперь не дублируется "6 раз" */
  background-position: top;
  /* При смене viewport'а привязка изображения к какой-либо стороне */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /*  Про vh тут сразу знал.. Он сначала px написал*/
  /* clip-path: polygon(0% 0%, 100% 0%, 100% 75%, 75% 75%, 75% 100%, 50% 75%, 0% 75%); */
  /* from the site: https://bennettfeely.com/clippy/ */
  /* CSS свойство clip-path создает ограниченную область, которая определяет какая часть элемента должна быть видимой. */
  /* more info about clip-path: https://developer.mozilla.org/ru/docs/Web/CSS/clip-path */
  height: 95vh;
  /* view port height... Крутая штука.. Сейчас поиграемся */
  /* за 24 минуты видео - хорошо узнал) */
  position: relative;
  /* TODO. Зачем он тут... выяснить*/
  /* UPD понял... без указания, logo-box считает от начала документа   */ }
  .header__logo-box {
    left: 4rem;
    position: absolute;
    top: 4rem; }
  .header__logo {
    height: 3.5rem; }
  .header__text-and-button {
    position: absolute;
    left: 50%;
    top: 40%;
    transform: translate(-50%, -50%);
    /* element itself */
    /* https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate */
    text-align: center;
    /* aligns button at center. Insead of applyting transform to button */ }

.section-about {
  background-color: #f7f7f7;
  padding: 25rem 0;
  margin-top: -20vh; }
